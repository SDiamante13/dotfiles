# Test Refactoring with MSW and Given/When/Then Pattern

## Key Learnings

### MSW Override Pattern: "Last Handler Wins"
- MSW (Mock Service Worker) allows easy test scenario setup through handler overrides
- When `msw.use()` is called with new handlers, they override existing ones for the same endpoints
- This enables clean test patterns where you set up a "happy path" baseline and override specific services for error scenarios
- Example:
```typescript
// Setup happy path in beforeEach
const givenHappyPathServices = () => {
  msw.use(
    mockSalesOrdersEndpoint(mockUnfulfilledSalesOrders),
    mockBomEndpoint(73034, mockBikeBomsByFinishedGoods),
    mockInventoryEndpoint(mockInventoryResponse, 200, '73034,73035')
  );
};

// Override specific service for error test
const givenInventoryServiceFails = () => {
  msw.use(mockInventoryEndpoint(null, 500)); // Overrides the happy path inventory endpoint
};
```

### Given/When/Then Test Pattern with Helper Functions
- Refactored acceptance tests to follow clean Given/When/Then structure
- Created semantic helper functions that read like natural language:
  - `givenInventoryServiceFails()`
  - `givenBomServiceRetriesOn500()`
  - `whenPlanningLineItemsApiIsCalled()`
- Each test becomes highly readable: setup scenario → execute action → verify outcome

### Reducing Test Code Duplication
- Created endpoint helper functions to eliminate repetitive `http.get()` mocking code
- Helper functions encapsulate common patterns like retry logic, delays, and parameter validation
- Example transformation:
```typescript
// Before: Repetitive and verbose
http.get(`${environment.romeApiBaseUrl}/search/v2/bom/by-finished-good/73035`, async () => {
  return HttpResponse.json(null, { status: 500 });
});

// After: Clean and reusable
const mockBomEndpoint = (itemId: number, response: any, status = 200) =>
  http.get(`${environment.romeApiBaseUrl}/search/v2/bom/by-finished-good/${itemId}`, async () =>
    HttpResponse.json(response, { status }));

// Usage
givenBomServiceFailsForSecondItem = () => msw.use(mockBomEndpoint(73035, null, 500));
```

### Mock Data Organization
- Moved reusable mock data from test files to centralized `planningData.ts`
- Prevents duplication and makes mock data available across multiple test files
- Improves maintainability when mock data structure needs to change

### TypeScript Nullable Type Handling
- When adding nullable fields to existing TypeScript schemas, need to handle both type definition and runtime usage
- Used `Type.Union([Type.Number(), Type.Null()])` for schema definition
- Added proper type guards and filtering in code: `.filter((id): id is number => id !== null)`
- Used non-null assertion (`!`) when logically guaranteed the value exists after filtering

### Test Assertion Focus
- Cleaned up test expectations to focus only on the behavior being tested
- Removed assertions that check implementation details (like specific `salesOrderId` values)
- Key principle: Tests should verify **what** the system does, not **how** it does it
- Examples of focused assertions:
  - Inventory failure test: Only check stock levels and warnings
  - BOM failure test: Only check BOM counts and error messages
  - Retry test: Focus on retry count verification, not result contents
  - Timeout test: Verify timeout duration and graceful degradation

## Anti-Patterns Avoided
- Don't check implementation details like specific array positions or IDs
- Don't duplicate endpoint mocking code across multiple test scenarios
- Don't embed large mock data structures directly in test files
- Don't mix "happy path" and error scenarios in the same test setup

## Best Practices Applied
1. **Semantic Test Functions**: Helper functions that read like domain language
2. **MSW Override Pattern**: Clean separation between baseline setup and error scenarios
3. **Centralized Mock Data**: Reusable mock structures in dedicated files
4. **Focused Assertions**: Only verify the specific behavior under test
5. **Type Safety**: Proper handling of nullable types with guards and assertions