# Test Data Refactoring Patterns

## Key Learnings from Manufacturing Test Refactoring

### 1. Eliminate Redundancy Through Factory Functions
Instead of creating dozens of similar mock objects with slight variations, use factory functions to generate test data. This reduced our test fixtures from 500+ lines to 269 lines (almost 50% reduction).

**Pattern:**
```typescript
const createManufacturingOrder = (id: number, name: string, status: string, hasBOMs = true) => ({
  ...createBase(),
  id,
  name,
  status,
  active: status === 'ESTIMATE' || status === 'ISSUED',
  productionQuantity: hasBOMs ? { '1': 5 } : {},
});
```

### 2. Single Source of Truth for Constants
Test data often duplicates dates, users, and metadata. Create shared constants:
```typescript
const DATES = {
  created: '2024-01-01T00:00:00Z',
  start: '2025-01-01T06:00:00Z',
  end: '2025-01-10T18:00:00Z',
};
const USER = 'user';
const PAGE_META = { totalPages: 1, totalElements: 1, pageNumber: 0 };
```

### 3. Avoid Backward Compatibility Aliases in Tests
Tests don't need backward compatibility. When refactoring test data:
- Remove all aliases immediately
- Update all references at once
- Tests either pass or fail - no gradual migration needed

### 4. Component Extraction for Error States
Identified repeated error UI pattern across modals:
```tsx
// Before: Duplicated in every component
<div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-md" role="alert">
  <p className="text-sm text-red-600">{error}</p>
</div>

// After: Reusable component
<ErrorAlert message={error} />
```

### 5. Simplify Test Helpers for Accessibility
When testing error messages, use semantic ARIA roles properly:
```typescript
// Good: Find by role, then check content
const alert = screen.getByRole('alert');
expect(alert).toHaveTextContent(errorText);

// Avoid: Complex nested queries
const alerts = screen.getAllByRole('alert');
alerts.some(alert => alert.textContent?.includes(errorText));
```

### 6. Type Safety vs Test Flexibility
For test fixtures, sometimes `any` type with ESLint disable is acceptable:
```typescript
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const createWorkOrderList = (workOrders: any[]): WorkOrderListResponse => ({
  content: workOrders,
  ...PAGE_META,
});
```
Tests need flexibility to mock edge cases that real API types might not allow.

## Impact
- Reduced test data file by 50% (500+ â†’ 269 lines)
- Eliminated 16+ redundant mock objects
- Removed all backward compatibility aliases
- All 146 tests still passing
- Better maintainability and DRY principles