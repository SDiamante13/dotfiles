# Contract Testing with MSW and the Mystery Guest Anti-Pattern

## Key Learning: Proper API Contract Testing Strategy

When testing external API integrations, it's crucial to separate **stable integration tests** from **contract validation tests**. This session demonstrated the importance of avoiding the "mystery guest" code smell while maintaining robust API contract verification.

## The Problem with Mixed Testing Approaches

Initially attempted to test Sleeper API transactions using real API calls, but this created several issues:
- **Unpredictable data**: Transaction data changes frequently and is not stable for testing
- **Flaky tests**: Real data variations cause tests to fail unpredictably
- **Poor feedback**: Hard to distinguish between API changes vs. code bugs

## The Solution: Hybrid Testing Strategy

### 1. Real Integration Tests for Stable Data
```typescript
// Keep real integration tests for data that doesn't change
it('fetches real user data for gaspjr', async () => {
  const sleeperApi = createSleeperApi();
  const user = await sleeperApi.getUser('gaspjr');
  
  expect(user.user_id).toBeDefined();
  expect(user.username).toBe('gaspjr');
});
```

### 2. MSW Contract Tests for Volatile Data
```typescript
// Use MSW with JSON fixtures for unstable data
const server = setupServer(
  http.get('https://api.sleeper.app/v1/league/league123/transactions/1', () => {
    return HttpResponse.json(transactionsFixture);
  })
);

it('fetches transactions with expected structure', async () => {
  const sleeperApi = createSleeperApi();
  const transactions = await sleeperApi.getTransactions('league123', 1);
  
  expect(transactions).toEqual([
    {
      type: 'free_agent',
      drops: { '1': '2124' },
      creator: 'user123',
      created: 1693843200000
    }
  ]);
});
```

## Avoiding the Mystery Guest Anti-Pattern

**Problem**: Tests that depend on external data files without making it obvious where the data comes from.

**Solution**:
1. **Explicit fixture imports**: `import transactionsFixture from './__fixtures__/transactions-response.json'`
2. **Clear MSW handlers**: Show exactly which endpoint returns which fixture data
3. **Whole object assertions**: Use `toEqual()` instead of individual property checks

## Technical Implementation Details

### ESLint Compliance Under Strict Rules
When functions exceed the 25-line limit, extract smaller functions:
```typescript
// Instead of one large function
function createSleeperApi() {
  return {
    getUser: async (username: string) => { /* 8 lines */ },
    getUserLeagues: async (userId: string) => { /* 8 lines */ },
    getTransactions: async (leagueId: string) => { /* 8 lines */ }
  };
}

// Extract to smaller functions
function createGetUser() { return async (username: string) => { /* logic */ }; }
function createGetUserLeagues() { return async (userId: string) => { /* logic */ }; }
function createGetTransactions() { return async (leagueId: string) => { /* logic */ }; }

function createSleeperApi() {
  return {
    getUser: createGetUser(),
    getUserLeagues: createGetUserLeagues(),
    getTransactions: createGetTransactions()
  };
}
```

### Handling Type Conflicts in Complex Dependencies
When MSW introduces tough-cookie type conflicts with Firebase Admin SDK:
- Use `"skipLibCheck": true` in tsconfig.json to bypass external library type issues
- Pin compatible versions when possible
- Focus on your code's type safety, not external dependency conflicts

### Test-Driven Development with External APIs
1. **Write failing tests first** - even for external integrations
2. **Use dependency injection** over mocks for better testability
3. **Separate concerns**: Real data validation vs. contract enforcement
4. **Make data sources obvious** in test files

## Architecture Insights

### Dependency Injection vs. Mocks
Prefer dependency injection patterns over Jest mocks for external services:
```typescript
// Good: Dependency injection
export function createFirebaseAppInitializer(
  firebaseInit: (config: unknown) => FirebaseApp,
  getExistingApps: () => FirebaseApp[],
  createCredential: (cert: unknown) => unknown
) {
  return function initializeFirebaseApp(config: FirebaseConfig): FirebaseApp {
    // Implementation uses injected dependencies
  };
}

// Avoid: Direct mocking with jest.mock()
```

This approach provides:
- **Better testability**: Easy to inject test doubles
- **Clearer interfaces**: Explicit about what the function needs
- **Flexibility**: Can inject different implementations for different environments

## Key Takeaways

1. **Separate stable from volatile data** in integration tests
2. **Make test data sources explicit** to avoid mystery guest pattern
3. **Use whole object assertions** for cleaner, more maintainable tests
4. **Prefer dependency injection** over mocking frameworks
5. **Handle type conflicts pragmatically** with skipLibCheck when needed
6. **Keep functions small** to comply with linting rules while maintaining readability

This approach creates a robust, maintainable testing strategy that catches real integration issues while providing reliable contract validation.